# moku-models

> Pydantic models for Moku device deployment, discovery, and configuration

## What is this?

Standalone Pydantic library defining type-safe data models for Moku platform specifications, deployment configurations, and signal routing.

**Key insight:** Single source of truth for platform specs used in both simulation (CocotB) and hardware deployment.

## Core Exports

### Platform Constants

```python
from moku_models import (
    MOKU_GO_PLATFORM,     # 2 slots, 2 I/O, 125 MHz, 16 DIO
    MOKU_LAB_PLATFORM,    # 2 slots, 2 I/O, 500 MHz, no DIO
    MOKU_PRO_PLATFORM,    # 4 slots, 4 I/O, 1.25 GHz, no DIO
    MOKU_DELTA_PLATFORM   # 3 slots, 8 I/O, 5 GHz, 32 DIO
)
```

### Key Classes

- `MokuConfig` - Central deployment abstraction (use this!)
- `SlotConfig` - Per-slot instrument configuration
- `MokuConnection` - Signal routing between ports and slots
- `MokuDeviceInfo` / `MokuDeviceCache` - Device discovery
- `MokuGoPlatform` / `MokuLabPlatform` / etc. - Platform specifications

## Basic Usage

```python
from moku_models import MokuConfig, SlotConfig, MokuConnection, MOKU_GO_PLATFORM

# Create deployment configuration
config = MokuConfig(
    platform=MOKU_GO_PLATFORM,
    slots={
        1: SlotConfig(instrument='CloudCompile', bitstream='path.tar'),
        2: SlotConfig(instrument='Oscilloscope', settings={'sample_rate': 125e6})
    },
    routing=[
        MokuConnection(source='IN1', destination='Slot1InA'),
        MokuConnection(source='Slot1OutA', destination='OUT1')
    ]
)

# Validate before deployment
errors = config.validate_routing()
if not errors:
    config_dict = config.to_dict()
```

## Platform Comparison

| Platform | Slots | I/O | Clock | DIO | Use Case |
|----------|-------|-----|-------|-----|----------|
| Go | 2 | 2×2 | 125 MHz | 16 pins | Education, portable |
| Lab | 2 | 2×2 | 500 MHz | None | Research, low noise |
| Pro | 4 | 4×4 | 1.25 GHz | None | High-performance |
| Delta | 3 | 8×8 | 5 GHz | 32 pins | Ultra-performance |

## Common Tasks

**Query platform specs:**
```python
from moku_models import MOKU_DELTA_PLATFORM

platform = MOKU_DELTA_PLATFORM
print(f"Clock: {platform.clock_mhz} MHz")
print(f"Period: {platform.clock_period_ns} ns")

# Get specific port
in1 = platform.get_analog_input_by_id('IN1')
print(f"IN1: {in1.resolution_bits}-bit @ {in1.sample_rate_msa} MSa/s")
```

**Export/import YAML:**
```python
import yaml
from moku_models import MokuConfig

# Export
config_dict = config.to_dict()
with open('deployment.yaml', 'w') as f:
    yaml.dump(config_dict, f)

# Import
with open('deployment.yaml') as f:
    data = yaml.safe_load(f)
config = MokuConfig.from_dict(data)
```

**Validate routing:**
```python
# MokuConfig validates:
# - Slot numbers within platform limits
# - All routing sources/destinations reference valid ports
# - Platform-specific constraints

errors = config.validate_routing()
# Returns: list[str] of validation errors (empty if valid)
```

## Documentation

- **README.md** - Installation and basic usage
- **CLAUDE.md** - AI assistant context and development guidelines
- **docs/MOKU_PLATFORM_SPECIFICATIONS.md** - Detailed hardware specs from datasheets
- **docs/routing_patterns.md** - Common MCC routing patterns and best practices
- **datasheets/** - Official Liquid Instruments PDFs

## File Structure

```
moku_models/
├── __init__.py          # Public API (import from here)
├── moku_config.py       # MokuConfig, SlotConfig
├── routing.py           # MokuConnection, MokuConnectionList
├── discovery.py         # MokuDeviceInfo, MokuDeviceCache
├── instrument.py        # (Future) Instrument-specific models
└── platforms/
    ├── moku_go.py       # MokuGoPlatform
    ├── moku_lab.py      # MokuLabPlatform
    ├── moku_pro.py      # MokuProPlatform
    └── moku_delta.py    # MokuDeltaPlatform
```

## Key Design Principles

1. **Single source of truth** - Same models for simulation AND hardware
2. **Type safety** - Pydantic validation catches errors before deployment
3. **Pure data models** - No deployment logic, just validated structures
4. **Moku API aligned** - Port naming matches 1st-party `moku` library

## Important Notes

- **Lab/Pro have NO DIO headers** (only Go and Delta)
- **Delta modeled in 3-slot mode** (8-slot advanced mode not yet supported)
- **Port naming**: Use `IN1`-`IN8`, `OUT1`-`OUT8` (not `Input1`, `Output1`)
- **Slot virtual ports**: `Slot1InA`, `Slot2OutB`, etc. (A/B/C/D channels)

## Integration Notes

**Used by:** moku-instrument-forge (deployment), CocotB testbenches (simulation), deployment automation tools

**Works with:**
- [basic-app-datatypes](https://github.com/sealablab/basic-app-datatypes) (sibling library) - Voltage type validation
- [riscure-models](https://github.com/sealablab/riscure-models) (sibling library) - Cross-platform voltage safety

**Validation flow:** MokuConfig → validate platform specs → validate routing → deployment-ready

## For More Details

**Deep context:** See [CLAUDE.md](CLAUDE.md) for:
- Complete platform specifications from datasheets
- Routing patterns and constraints
- Integration with sibling libraries
- Development workflow
- Instrument configuration patterns

**API documentation:** See [README.md](README.md) for installation

**Datasheets:** See [datasheets/](datasheets/) for official Liquid Instruments PDFs

---

**Version:** Current
**Last Updated:** 2025-11-04
**License:** MIT
**Part of:** [moku-instrument-forge-mono-repo](https://github.com/sealablab/moku-instrument-forge-mono-repo) (monorepo orchestrator)
**Used by:** [moku-instrument-forge](https://github.com/sealablab/moku-instrument-forge) (forge code generation)
